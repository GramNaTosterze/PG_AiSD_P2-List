%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                 WERSJA POLSKA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Obecne komputery posiadają pamięci RAM różnych prędkości.
Często posiadają tzw. pamięć cache: https://pl.wikipedia.org/wiki/Pami%C4%99%C4%87_podr%C4%99czna_procesora.
Dane są ładowane do pamięci podręcznej oraz zapisywane z pamięci podręcznej blokami.
Stąd też, możliwe, że istnieje pewien sens w zaimplementowaniu listy, która byłaby w pewien sposób na to ukierunkowana.

Celem projekt jest zaimplementowanie listy. Zadanie jest w 2 wersjach:
 a) Prosta lista dwukierunkowo -- dokładnie jak w materiałach wykładowych.
 b) List dwukierunkowa oparta o bloki danych.
    Lista jest budowana pod warunkiem, że elementy na liście są małe, zaś blok pamięci duże (względem elementów).
    Tutaj należy operować na blokach o stałej ilości bajtów, np. 64 bajtowych i upakowywać elementy (oraz metadane) w blokach.   
    Dowolna rozsądna organizacja bloków ma sens, przykładowo:
    - Pierwsze x bajtów to adres poprzedniego bloku.
    - Następne x bajtów to adres następnego bloku.
    - Później zaś może być bajt mówiąc ile elementów jest w bloku.
    - Następnie zaś poszczególne elementy.
    Każdy może zaproponować własną organizację pod warunkiem, że będzie ona dobrze wykorzystywać pamięć.
    Przykładem negatywnym jest np. organizacja, że w bloku znajduje się zawsze dokładnie jeden element.
    Taka organizacja nie zostanie oceniona pozytywnie.

Dane przechowywane to liczby 8 bajtowe -- type unsigned long long int wystarczy do przechowywania ich i obsługi wejścia-wyjścia.
Lista ma dodatkowo do 10 iteratorów: iterator wskazuje na poszczególny element na liście. 
Są dwa stałe iteratory BEG i END, wskazujące odpowiednio na początek i koniec listy. 
Blok danych ma rozmiar w przedziale (włącznie) od 64B, do co najwyżej 1024B.
Zaimplementowana lista powinna obsługiwać dowolny rozmiar w tym przedziale -- ustalenie bloku na stały rozmiar 1024B jest niewystarczające.

Interfejs:
Operacje które będą podawane na wejściu to:
   I x             -- Parametr x to rozmiar bloku.
                      Użyj go w przypadku listy opartej o bloki aby budować bloki odpowiednich rozmiarów.
                      W przypadku listy prostej wczytaj, ale zignoruj.
   i x y           -- Zainicjuj iterator o numerz x na pozycję y.
                      Wartość y to albo [BEG], albo [END], albo numer.
                      Jeżeli to numer i' to element wskazywany powinien zostać skopiowany z iteratora i'.
                      Iterator może zostać inicjowany wiele razy i oczywiście nie powinno to robić problemów typu wycieki pamięci.
                      Iteratory (poza BEG i END) są etykietowane od 0 do 9.
   + x             -- Przesuń iterator numer x do przodu.
                      Jeżeli przesunięcie jest to niemożliwe to iterator powinien wskazywać na ostatni element..
   - x             -- Cofnij iterator o numerze x.
                      Jeżeli to niemożliwe, to iterator powinien zacząć wskazywać na I element.
  .A x y           -- Dodaj liczbę y przed pozycję wskazywaną przez x.
                      x może być albo [BEG] albo [END], albo numerem iteratora.
                      W przypadku pustej listy dodaj liczbę y i zainicjuj BEG i END odpowiednio.
   A. x y          -- Dodaj liczbę y za pozycję x.
                      Jak poprzednio x może być równy [BEG] lub [END] lub numerem iteratora.
                      W przypadku pustej listy dodaj liczbę y i zainicjuj BEG i END odpowiednio.
   R x             -- Usuń element wskazywany przez x.
                      x może być równy [BEG] lub [END] lub numerowi iteratora.
                      Jeżeli element został usunięty, to wszystkie iteratory uprzednio wskacujące na niego powinny zacząć wskazywać na kolejny element.
                      Jeżeli to niemożliwe (usunięto ostatni element na liście), to powinny wskazywać na koniec listy.
                      Jeżeli to niemożliwe (usunięto ostatnie element z listy), to powinny być niezainicjowane.
   P p             -- Wypisz elementy.
                      Jeżeli wartość parametru p to [ALL] to wypisz wszystkie od początku do końca.
                      Jeżeli p jest numerem, to wypisz element wskazywany przez p-ty iterator.

Zwróć uwagę na wpływ operacji A i R na listę opartą o bloki.
Operacja A powinna tworzyć, jeżeli to konieczne, nowy blok.
Nie będzie jednak dobrze, jeżeli będzie możliwość utworzenia wielu pustych bloków -- w przypadku podziału dziel elementy między bloki po równo.
Operacja R może spowodować, że blok stanie się słabo wypełniony, np. ilość elementów będzie mniejsza niż 1/3 maksymalnej możliwej. 
W tym przypadku, jeżeli istnieje blok sąsiedni o nie minimalnej ilości elementów, to należy przesunąć element z sąsiedniego bloku. 
Jeżeli zaś to niemożliwe, to należy scalić blok z jednym z sąsiadów -- jeżeli są oczywiście co najmniej 2 bloki. 

Wszystkie operacje (poza P ALL) powinny działać w czasie O(BLOCK_SIZE), tj. każda operacja może działać w czasie proporcjonalnym do rozmiaru bloku.
Będzie bardzo źle, jeżeli przykładowo dodanie elementu będzie wymagało przejścia wszystkich elementów na liście. 

Szczegóły oceny: 
 - Lista oparta o bloki warta jest do 100%.
   Lista prosta warta jest do 80%.
   Operacje takie jak dodawanie elementów, usuwanie elementów, oraz iteratory są w przybliżeniu równie ważne.
 - W przypadku listy opartej o bloki jest kluczowe, aby program operował na blokach o stałym rozmiarze i wykorzystywał dobrze pamięć.
   Jest również kluczowe, aby element które są blisko na liście były w tym samym lub sąsiednich (powiązanych) blokach.
   Niedoskonałe będzie jeżeli metadane odnośnie bloków (przykładowo adres sąsiednich bloków, albo ilość elementów w bloku) będą trzymane osobno (przykładowo jako niezależna lista).
 - Program powinien wczytać wejście, przetworzyć komendy z wejścia, i się zakończyć.
   Jeżeli program nie zakończy się po przeczytaniu ostatniej komendy z wejścia, to zostanie przydzielona kara.
 - Za wyjątkową nieefektywność, przykładowo przeglądanie całej listy w celu dodania elementu, zostanie przydzielona solidna kara.
 - Wszystkie operacje (poza P ALL) powinny działać w czasie O(BLOCK_SIZE) (ograniczonym przez stałą razy rozmiar bloku).
 - Pamięć powinna zostać zwolniona przed zakończeniem programu.
 - Nie używać klasy string.

Wskazówki:
 - Upewnij się, że wszystko zostało załadowane na STOS w czasie.
 - Wersja blokowa nie jest trudna. Może jednak zająć trochę więcej czasu niż podstawowa. Zacznij projekt wcześnie.
   Możliwe, że warto zaimplementować wersję uproszczoną na wszelki wypadek. 
   Obi wersje mogą zostać załadowane na STOS: tpikies_project_CacheList_simplified jest na uproszczoną, tpikies_project_CacheList_normal na zwykłą. 
 - Możliwe, że warto budować program małymi przyrostami. 
   Zaimplementuj najmniejszy zestaw operacji które zagwarantują, że program działa choć częściowo.
   Przykładowo, najpierw dodawanie, później usuwanie, później iteratory.
 - Używaj asercji i małych testów, przykładowo: że indeksy el. są w porządku, że blok nie jest pełen przy dodawaniu, że blok z którym następuję scalenie istnieje itd.
   Możliwe, że warto napisać krótką procedurę która sprawdzi, że lista jest spójna i zdrowa.
 - Warto, jak zwykle, podzielić logikę programu na wiele małych funkcji.
   Niech wykonanie funkcji gwarantuje pewną własność. p
   Pzykładowo, przesunięcie elementów między blokami może gwarantować, że dane w obu blokach są poprawne i iteratory zostały zaktualizowane.
 - Aby sprawdzić, że wejście zostało wczytane można użyć kodu takiego jak:
   char command [100];
   while(true)
   {
    scanf("%s", command);
    if(feof(stdin)!=0)
    {
     break;
    }
    // Parsing Commands 
   }
   Pętla while kończy się, gdy wejście zostały wczytane całe.
 - Można używać funkcji z string.h. Nie trzeba pisać konwersji liczba -> tekst ręcznie. 
   Co więcej, przykładowo strcmp/sscanf pozwalają stwierdzić, czy wejście, to liczba stały tekst, itd.

Testy:
1,2: proste dodawanie
3,4: proste usuwanie
5,6: dodawanie i usuwanie połączone
7,...,11: podstawy iteratorów
12: większy test na dodawanie
13: większy test na usuwanie
14: większy test na 2 iteratory
15: większy test na 10 iteratorów


Dodatkowe wyjaśnienia:

1. Podział bloków:
Załóżmy, że chcemy wykonać operację A i dodać element 6 między elementami 5 i 7.
Blok B jest pełen więc należy podzielić go na B' i B'', po podziale dodać element. 

         B               
   +-----------+   
   |prev block |
   |next block |
   |     6     |
   +-----------+
   |     1     |
   |     2     |
   |     3     |
   |     4     |
   |     5     |
   |     7     |
   +-----------+

zmienia sie w:

         B'                B''
   +-----------+     +-----------+
   |prev block |     |B'         |
   |B''        |     |next block |
   |     3     |     |     4     |
   +-----------+     +-----------+
   |     1     |     |     4     |
   |     2     |     |     5     |
   |     3     |     |     6     |
   |           |     |     7     |
   |           |     |           |
   |           |     |           |
   +-----------+     +-----------+

2. Przesuwanie elementów przy operacji R:
Założmy, że mamy taką sytuację

         B                 B'                B''
   +-----------+     +-----------+     +-----------+
   |prev block |     |B          |     |B'         |
   |B''        |     |B''        |     |next block |
   |     3     |     |     2     |     |     2     |
   +-----------+     +-----------+     +-----------+
   |     1     |     |     4     |     |     6     |
   |     2     |     |     5     |     |     7     |
   |     3     |     |           |     |           |
   |           |     |           |     |           |
   |           |     |           |     |           |
   |           |     |           |     |           |
   +-----------+     +-----------+     +-----------+

i usuwany jest element 4. W tym przypadku blok B' miałby małe wykorzystanie pamięci.

Można więc przesunąć 3 z B do B' i usunąć 4 -- wykorzystanie będzie akceptowalne.

         B                 B'                B''
   +-----------+     +-----------+     +-----------+
   |prev block |     |B          |     |B'         |
   |B''        |     |B''        |     |next block |
   |     2     |     |     2     |     |     2     |
   +-----------+     +-----------+     +-----------+
   |     1     |     |     3     |     |     6     |
   |     2     |     |     5     |     |     7     |
   |           |     |           |     |           |
   |           |     |           |     |           |
   |           |     |           |     |           |
   |           |     |           |     |           |
   +-----------+     +-----------+     +-----------+

3. Scalanie bloków:
Załóżmy, że teraz chcielibyśmy usunąć 3. Nie można przesunąć żadnego element z sąsadiów (gdyż one wtedy miałyby problem). 
Ale można scalić B' i B'' oraz usunąć 3 -- wykorzystanie pamięci będzie dobre.

         B                B'+B''      
   +-----------+     +-----------+
   |prev block |     |B          |
   |B'+B''     |     |next block |
   |     2     |     |     3     |
   +-----------+     +-----------+
   |     1     |     |     5     |
   |     2     |     |     6     |
   |           |     |     7     |
   |           |     |           |
   |           |     |           |
   |           |     |           |
   +-----------+     +-----------+

Zauważ, że czas potrzebny na wykonanie tych operacji ~ maks. ilość elementów w 3 blokach.


Przykładowe dane.

Wejście 1:
I 64
.A BEG 10
P ALL
.A BEG 9
P ALL
.A BEG 8
P ALL
.A BEG 7
P ALL
.A BEG 6
P ALL
R BEG
P ALL
R BEG 
P ALL
R BEG
P ALL
R BEG
P ALL
.A BEG 5
P ALL
.A BEG 4
P ALL
.A BEG 3
P ALL
.A BEG 2
P ALL
.A BEG 1
P ALL

Wyjście:
10 
9 10 
8 9 10 
7 8 9 10 
6 7 8 9 10 
7 8 9 10 
8 9 10 
9 10 
10 
5 10 
4 5 10 
3 4 5 10 
2 3 4 5 10 
1 2 3 4 5 10 

Wejście 2:
I 64
A. BEG 1
A. END 2
A. END 3
A. END 4
A. END 6
P ALL
i 0 BEG
+ 0
+ 0
R 0 
P ALL
A. 0 5
P ALL
.A 0 3
P ALL

Wyjście:
1 2 3 4 6 
1 2 4 6 
1 2 4 5 6 
1 2 3 4 5 6 


